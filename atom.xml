<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>木子的博客</title>
  
  <subtitle>欲买桂花同载酒 终不似少年游</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-06-03T17:57:56.291Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>lish</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello 大家好</title>
    <link href="http://example.com/2024/06/03/hello-world/"/>
    <id>http://example.com/2024/06/03/hello-world/</id>
    <published>2024-06-03T14:24:40.109Z</published>
    <updated>2024-06-03T17:57:56.291Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎大家光临木子的博客，在这里希望有能帮到你的地方。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;欢迎大家光临木子的博客，在这里希望有能帮到你的地方。&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>作用域和作用域链、柯里化、闭包、暂时性死区总结</title>
    <link href="http://example.com/2024/05/23/%E6%80%BB%E7%BB%93JS%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E3%80%81%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E3%80%81%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA%E3%80%81%E6%9F%AF%E9%87%8C%E5%8C%96%E3%80%81%E9%97%AD%E5%8C%85/"/>
    <id>http://example.com/2024/05/23/%E6%80%BB%E7%BB%93JS%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E3%80%81%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E3%80%81%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA%E3%80%81%E6%9F%AF%E9%87%8C%E5%8C%96%E3%80%81%E9%97%AD%E5%8C%85/</id>
    <published>2024-05-23T12:55:10.000Z</published>
    <updated>2024-06-15T11:00:08.690Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们总是会看到或者听到作用域和作用域链、柯里化、闭包等词语，甚至使用到，趁着现在我总结一下，希望可以帮助大家了解它们，也希望得到大家的指点。</p><h3 id="什么是作用域？"><a href="#什么是作用域？" class="headerlink" title="什么是作用域？"></a>什么是作用域？</h3><p>作用域是指 js 变量使用时所存在的一个区域，简单来说就是可访问区域。</p><pre><code class="ts">window.a = 1function a()&#123;// 输出 1，虽然局部没有 a 变量，但是 全局中有。console.log(a)var b = 2&#125;// 报错，全局中无法使用局部变量。console.log(b)</code></pre><h3 id="js有哪些作用域？"><a href="#js有哪些作用域？" class="headerlink" title="js有哪些作用域？"></a>js有哪些作用域？</h3><p>js具体有如下作用域</p><ul><li><strong>Global全局作用域</strong>：在浏览器环境下就是 window，在 node 环境下是 global</li><li><strong>Local函数作用域</strong>：本地作用域，或者叫函数作用域</li><li><strong>Block块级作用域</strong>：es5之前只有函数作用域和全局作用域，es6开始引入了块级作用域</li><li><strong>Script作用域</strong>：let、const 声明的全局变量会保存在 Script 作用域，这些变量可以直接访问，但却不能通过 window.xx 访问，如果需要访问需要把变量挂载在全局作用域上。</li><li><strong>模块作用域</strong>：其实严格来说这也是函数作用域，因为 node 执行它的时候会包一层函数，算是比较特殊的函数作用域，有 module、exports、require 等变量</li><li><strong>Catch Block 作用域</strong>：catch 语句的作用域可以访问错误对象</li><li><strong>With Block 作用域</strong>：with 语句的作用域就是传入的对象的值</li><li><strong>Closure 作用域</strong>：函数返回函数的时候，会把用到的外部变量保存在 Closure 作用域里，这样再执行的时候该有的变量都有，这就是闭包。eval 的闭包比较特殊，会把所有变量都保存到 Closure 作用域</li><li><strong>Eval 作用域</strong>：eval 代码声明的变量会保存在 Eval 作用域</li></ul><h3 id="什么是作用域链？"><a href="#什么是作用域链？" class="headerlink" title="什么是作用域链？"></a>什么是作用域链？</h3><p>在局部作用域使用变量时，如果在自己作用域找不到对应变量，则会往上一级作用域查找，直到全局作用域，如果全局作用域无此变量则会报 undefined。相反，全局作用域中无法使用局部作用域中的变量。</p><pre><code class="ts">window.a = 1function a()&#123;    //函数作用域中没有声明a但是往上级作用域中一直找，到window全局作用域中找到了a    console.log(a)&#125;</code></pre><h3 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h3><p>如下add函数中声明了sum  但是add的匿名函数中使用到了sum，这样就形成了闭包，红宝书中说闭包是指有权访问另一个函数作用域中的变量的函数。因为匿名函数中会使用到sum，此时sum会存储到Closure作用域中。</p><pre><code class="ts">var add = function()&#123;     let sum = 0     return function()&#123;         return sum + 1     &#125; &#125;</code></pre><ul><li>使用闭包的目的――隐藏变量，间接访问一个变量，在定义函数的词法作用域外，调用函数。</li><li>闭包通常在回调函数、私有属性、函数柯里化中使用。</li></ul><h3 id="什么是柯里化？"><a href="#什么是柯里化？" class="headerlink" title="什么是柯里化？"></a>什么是柯里化？</h3><p>函数柯里化就是将一个多参函数转为单参函数，简化函数的传参，但是会增加函数内部的复杂程度。</p><pre><code class="ts">// 正常计算两数相加的方法 function sum(x, y)&#123;     return x + y  &#125; console.log(sum(2, 2)) // 使用闭包实现柯里化 function sum(x)&#123;     return function(y)&#123;         return x + y     &#125; &#125; function sum_t(x)&#123;     //可以执行A逻辑    return function(y)&#123;         //可以执行B逻辑        return function(z)&#123;             return z+ x + y         &#125;     &#125; &#125; // 先声明一个变量拿到自增方法(匿名函数) const sum_function = sum(1) // 在调用这个方法进行自增，输出：3 console.log(sum_function(2)) // 亦或者直接调用sum方法传入两个参数，输出也是：3 console.log(sum(1)(2))//当然如果有更多的参数比如sum_t方法,可以变成如下这种调用方式，但是柯里化层数太多了个人觉得复杂度会提升很大，不是很有必要。sum_t(1)(2)(3)</code></pre><h3 id="什么是变量提升"><a href="#什么是变量提升" class="headerlink" title="什么是变量提升"></a>什么是变量提升</h3><p>变量可以在声明之前使用，值为<code>undefined</code>。这种感觉比较奇怪的现象就是变量提升。</p><p>为了纠正这种现象，<code>let</code>命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p><p>下面代码中，变量<code>foo</code>用<code>var</code>命令声明，会发生变量提升，即脚本开始运行时，变量<code>foo</code>已经存在了，但是没有值，所以会输出<code>undefined</code>。变量<code>bar</code>用<code>let</code>命令声明，不会发生变量提升。这表示在声明它之前，变量<code>bar</code>是不存在的，这时如果用到它，就会抛出一个错误。</p><pre><code class="ts">// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2;</code></pre><h3 id="什么是暂时性死区"><a href="#什么是暂时性死区" class="headerlink" title="什么是暂时性死区"></a>什么是暂时性死区</h3><p>在变量声明前就使用变量，这种情况会报错，就是暂时性死区，比如下面的代码</p><pre><code class="ts">if (true) &#123;  // 暂时性死区开始  name = &#39;小明&#39;; // ReferenceError  console.log(name); // ReferenceError  let name; // 暂时性死区结束  console.log(name); // undefined  name = &#39;大明&#39;;  console.log(name); // 大明&#125;</code></pre><p>暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>   把自己的理解，再加上查阅资料，整合成了这个文档，如果有不对的地方希望大家指正，有些作用域我自己也没关注，趁着这个机会，终于也有了大致的了解，再一次变成了我写博客的动力，只要写了就会有收获，加油。</p>]]></content>
    
    
    <summary type="html">什么是作用域和作用域链、柯里化、闭包、暂时性死区？</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>总结vue3响应式原理与ref、reactive</title>
    <link href="http://example.com/2024/05/23/%E6%80%BB%E7%BB%93vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E4%B8%8Eref%E3%80%81reactive/"/>
    <id>http://example.com/2024/05/23/%E6%80%BB%E7%BB%93vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E4%B8%8Eref%E3%80%81reactive/</id>
    <published>2024-05-23T12:55:10.000Z</published>
    <updated>2024-06-15T10:57:51.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>vue2的响应式通过Object.defineProperty将data转为响应式，而vue3则通过Proxy实现，性能得到显著提升，那么vue3的响应式系统做了什么呢？发生了哪些变化？</p><h3 id="vue3通过什么api实现响应式数据声明，怎么实现？"><a href="#vue3通过什么api实现响应式数据声明，怎么实现？" class="headerlink" title="vue3通过什么api实现响应式数据声明，怎么实现？"></a>vue3通过什么api实现响应式数据声明，怎么实现？</h3><p>对比vue2，响应式数据都声明在<code>data()&#123;&#125;</code>中，但是vue3则需要我们通过api自己声明，如下就是声明vue3响应式的代码。</p><pre><code class="ts">setup() &#123;    const msg = ref(&#39;想吃炸鸡&#39;)    const obj = reactive(&#123;      name:&quot;深圳不怕影子斜&quot;    &#125;)    console.log(obj,msg);    return &#123; msg,obj &#125;  &#125;,</code></pre><p>看完这个案例之后，是不是想了解怎么实现一个简单的响应式数据结构和理解他的原理呢？</p><h4 id="第一步：实现一个简单的reactive"><a href="#第一步：实现一个简单的reactive" class="headerlink" title="第一步：实现一个简单的reactive"></a>第一步：实现一个简单的reactive</h4><pre><code class="ts">let reactive = function(obj)&#123;    //返回劫持obj的Proxy对象    return new Proxy(obj, &#123;        //劫持get        get(target, key) &#123;            return target[key]        &#125;,        //劫持set        set(target, key, value) &#123;            target[key] = value        &#125;    &#125;)&#125;//声明一个reactivelet reactive_data = reactive(&#123;age:30&#125;)a.age = 40console.log(a.age)</code></pre><p>接下来我们可以看到我们修改了值改成了40，我的reactive方法通过Proxy劫持对象，实现了一个简单的响应式方法，这就是Vue 3 使用了 Proxy 来创建响应式对象的原理，当然vue3考虑的会更全面，我们这只是一个简单的案例，理解他怎么实现的。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8f2aa768d5b475e81d6c6f99f2bba46~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=250&h=166&s=16823&e=jpg&b=fefefe" alt="01.png"></p><h4 id="既然有了reactive-为什么还会有ref呢？"><a href="#既然有了reactive-为什么还会有ref呢？" class="headerlink" title="既然有了reactive,为什么还会有ref呢？"></a>既然有了reactive,为什么还会有ref呢？</h4><p>接下来我们看一段代码</p><pre><code class="ts">  setup() &#123;    const obj = reactive(1)    console.log(&#39;打印A&#39;,obj);    obj++    console.log(&#39;打印B&#39;,obj);    return &#123; obj &#125;  &#125;,</code></pre><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ba93320344444089f28396b804f0fe0~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=850&h=220&s=21235&e=png&b=fef2e5" alt="image.png"><br>再看上面控制台打印的，你会发现通过reactive直接声明number,string,boolean等值类型的响应式数据，是不支持的，直接提示了错误，原因是Proxy只能劫持对象，那我们需要写成下面这样,打印结果正常了。</p><pre><code class="ts">  setup() &#123;    const obj = reactive(&#123;value:1&#125;)    console.log(&#39;打印A&#39;,obj)    obj.value++    console.log(&#39;打印B&#39;,obj)    return &#123; obj &#125;  &#125;,</code></pre><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69447c1021144132a976d4c50848f355~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=400&h=78&s=7171&e=png&b=fffefe" alt="image.png"></p><h4 id="第二步-先实现一个简单的ref"><a href="#第二步-先实现一个简单的ref" class="headerlink" title="第二步:先实现一个简单的ref"></a>第二步:先实现一个简单的ref</h4><pre><code class="ts">&lt;script&gt;function ref(value) &#123;    const refObject = &#123;        get value() &#123;          return value        &#125;,        set value(newValue) &#123;          value = newValue        &#125;    &#125;    return refObject&#125;//声明响应式const age = ref(18)//打印出18console.log(&#39;ref&#39;,age.value)//赋值加1age.value ++//打印出19console.log(&#39;ref&#39;,age.value)&lt;/script&gt;</code></pre><p>运行结果如下</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1d47b6d343e4070bdfb46b58480d845~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=195&h=67&s=1403&e=png&b=ffffff" alt="image.png"></p><p>通过上面这个案例，我们去传入一个对象时，发现又报错了，如下</p><pre><code class="ts">let ref = ref(&#123;name:&quot;小明&quot;,age:18&#125;)console.log(&#39;ref&#39;,refa.value.age);refa.value.age ++console.log(&#39;ref&#39;,refa.value.age);</code></pre><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/683d9ec0c37c456d83fede7a4feee1f6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=849&h=241&s=25941&e=png&b=fef5d7" alt="image.png"></p><p>这是因为，真正的ref是通过RefImpl类实现的时候，在构造器和set参数时动态的判断了是否是object对象，如果是则通过reactive实现，那么我们按照他的思路写一个简单的案例，继续改造一下我们的ref</p><pre><code class="ts">&lt;div&gt;    &lt;button onclick=&quot;age_click()&quot;&gt;点我增加年龄&lt;/button&gt;&lt;/div&gt;&lt;script&gt;//首先简单的实现一下isObjectconst isObject = (value)=&gt; typeof value === &#39;object&#39;//第二步实现toReactive，是否为对象，如果是则调用之前写好的reactive方法const toReactive = (value) =&gt; isObject(value) ? reactive(value) : value//第三步实现一下RefImplclass RefImpl &#123;    _value =&#39;&#39;    constructor(value) &#123;        //在这里初始化值，真实的RefImpl类构造器里面还初始化了很多东西        this._value = isObject(value) ? toReactive(value) : value;    &#125;    get value() &#123; // getter方法 获取value值        console.log(&#39;get了&#39;,this._value);        return this._value;    &#125;    set value(newVal) &#123; // setter方法 设置value值        this._value = isObject(newVal) ?  toReactive(newVal):newVal;  // 判断是否为object，是则调用toReactive        console.log(&#39;set了&#39;,newVal);    &#125;&#125;//那么我们的ref就可以简化如下了let ref =function(value)&#123;    return new RefImpl(value)&#125;const obj = ref(&#123;age:18&#125;)let age_click =()=&gt;&#123;    console.log(&#39;对象的age&#39;,obj.value.age)    obj.value.age ++    console.log(&#39;对象的age&#39;,obj.value.age)&#125;&lt;/script&gt;</code></pre><p>这个时候我们能看到的结果如下，至此，ref实现了可以传入对象进行响应式的操作。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a088cdb3280f42b693fc3dcd246f5e9c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=516&h=177&s=14155&e=png&b=fffefe" alt="image.png"></p><h3 id="实现了数据响应，怎么实现数据变了页面也跟着变？"><a href="#实现了数据响应，怎么实现数据变了页面也跟着变？" class="headerlink" title="实现了数据响应，怎么实现数据变了页面也跟着变？"></a>实现了数据响应，怎么实现数据变了页面也跟着变？</h3><p>我们上面虽然实现了数据的响应，可是他什么时候会更新呢？这个就涉及到vue的track和trigger，我们劫持了数据的get和set，在get的时候track收集依赖（发布订阅），在set的时候触发trigger（通知订阅）的update进行更新。思路有了那我们来写一个简单的案例理解一下</p><pre><code class="ts">&lt;div&gt;    &lt;button onclick=&quot;age_click()&quot;&gt;点我增加年龄&lt;/button&gt;    &lt;div &gt;我的age现在是&lt;span id=&quot;update_span&quot;&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;// 首先先将activeWatcher设为null 确保在初始化阶段没有活动的Watcher对象let activeWatcher = null;// 创建 Watcher 类，通过构造函数绑定update函数，并实现update更新回调class Watcher &#123;    constructor(updateFn) &#123;        this.updateFn = updateFn;    &#125;    // 执行更新操作    update() &#123;        this.updateFn();    &#125;&#125;//创建更新操作方法，更新页面数据let update = ()=&gt;&#123;    console.log(&#39;更新页面元素开始&#39;);    document.querySelector(&quot;#update_span&quot;).innerHTML = age.value.age;    console.log(&#39;更新页面元素结束&#39;);&#125;//实例化一个WatcheractiveWatcher = new Watcher(update)// 创建依赖管理类Dep，通过构造函数初始化依赖收集器，实现track收集依赖class Dep &#123;    constructor() &#123;        // 用于存储依赖的订阅者        this.subscribers = new Set();    &#125;    // 添加订阅者    track=(key) =&gt;  activeWatcher &amp;&amp; this.subscribers.add(activeWatcher)    // 通知所有订阅者进行更新    trigger=()=&gt; this.subscribers.forEach((watcher) =&gt; watcher.update())&#125;//new 一个依赖收集器const dep = new Dep();//基于上面的reactive方法，添加了dep.track() //发布订阅和dep.trigger() //通知订阅let reactive = function(obj)&#123;    return new Proxy(obj, &#123;        get(target, key) &#123;            // track(target, key)//vue的发布订阅            dep.track() //发布订阅            // return Reflect.get(target,key)             return target[key]        &#125;,        set(target, key, value) &#123;            console.log(&#39;set了&#39;,value);            target[key] = value            // vue3底层的对象响应式的雏形是这样的，利用proxy代理，利用reflect反射            // Reflect.set(target,key,value)            // trigger(target, key)            dep.trigger() //通知订阅        &#125;    &#125;)&#125;//简单的实现isObjectlet isObject = (value)=&gt; typeof value === &#39;object&#39;// 是否为对象，如果是则调用reactiveconst toReactive = (value) =&gt; &#123;return isObject(value) ? reactive(value) : value&#125;; //根据上面的RefImpl，添加dep.track()和dep.trigger()class RefImpl &#123;    _value =&#39;&#39;    constructor(value) &#123;        //在这里初始化值，真实的RefImpl类构造器里面还初始化了很多东西        this._value = isObject(value) ? toReactive(value) : value;    &#125;    get value() &#123; // getter方法 获取value值        dep.track()        console.log(&#39;get了&#39;,this._value);        return this._value;    &#125;    set value(newVal) &#123; // setter方法 设置value值        this._value = isObject(newVal) ?  toReactive(newVal):newVal;  // 判断是否为object，是则调用toReactive        console.log(&#39;set了&#39;,newVal);        dep.trigger()    &#125;&#125;//实现reflet ref =function(value)&#123;    return new RefImpl(value)&#125;//声明一个refconst age = ref(&#123;age:18,name:&#39;aaa&#39;&#125;);//实现clicklet age_click =()=&gt;&#123;    age.value.age++&#125;//把值初始化挂载在页面update()&lt;/script&gt;</code></pre><p>这个时候我们看到了初始化把age挂载在页面上的效果，模拟成功</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6560dad57401416f91c9b469fd8a3e9b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=577&h=543&s=29355&e=png&b=fefefe" alt="image.png"><br>再看看点击一下按钮之后的效果</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5eb3e672c1714b3bb67c34743991746a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=582&h=721&s=44729&e=png&b=fefefe" alt="image.png"><br>至此，模拟成功，这个是一个简单的例子，来帮助我们理解响应式的原理，实际的vue发布订阅以及响应更新页面元素会更复杂。</p><h3 id="ref和reactive的注意事项"><a href="#ref和reactive的注意事项" class="headerlink" title="ref和reactive的注意事项"></a>ref和reactive的注意事项</h3><ul><li>reactive() 返回的是一个原始对象的 Proxy，它和原始对象是不相等的</li></ul><pre><code class="ts">const raw = &#123;&#125;const proxy = reactive(raw)// 代理对象和原始对象不是全等的console.log(proxy === raw) // false</code></pre><ul><li>只有代理对象是响应式的，更改原始对象不会触发更新。因此，使用 Vue 的响应式系统的最佳实践是<strong>仅使用你声明对象的代理版本</strong></li></ul><pre><code class="ts">const raw = &#123;age:18&#125;//非响应式数据const proxy = reactive(raw)//响应式数据raw.age =19  //不会触发页面更新proxy.age =19 //会触发页面更新</code></pre><ul><li>reactive使用时不能替换整个对象：由于 Vue 的响应式跟踪是通过属性访问实现的，因此我们必须始终保持对响应式对象的相同引用。</li></ul><pre><code class="ts">let state = reactive(&#123; count: 0 &#125;)// 上面的 (&#123; count: 0 &#125;) 引用将不再被追踪// (响应性连接已丢失！)state = reactive(&#123; count: 1 &#125;)</code></pre><ul><li>reactive对解构操作不友好：当我们将响应式对象的原始类型属性解构为本地变量时，或者将该属性传递给函数时，我们将丢失响应性连接，在对象需要解构的时候，建议配合<code>toRefs</code>使用</li></ul><pre><code class="ts">const state = reactive(&#123; count: 0 &#125;) // 当解构时，count 已经与 state.count 断开连接 let &#123; count &#125; = state // 不会影响原始的 state count++ // 该函数接收到的是一个普通的数字 // 并且无法追踪 state.count 的变化 // 我们必须传入整个对象以保持响应性 callSomeFunction(state.count)//基于这个问题所以官方建议我们使用ref</code></pre><ul><li>额外的 ref 解包细节</li></ul><pre><code class="ts">const count = ref(0) //一个 ref 会在作为响应式对象的属性被访问或修改时自动解包,count在reactive中被解包const state = reactive(&#123; count &#125;)//只有当嵌套在一个深层响应式对象内时，才会发生 ref 解包。当其作为shallowReactiv浅层响应式的属性被访问时不会解包//如果将一个新的 ref 赋值给一个关联了已有 ref 的属性，那么它会替换掉旧的 ref//当 ref 作为响应式数组或原生集合类型 (如 `Map`) 中的元素被访问时，它不会被解包//ref在template模板中可以自动解包</code></pre><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>上次在博客上看说vue3的响应式底层使用到了Reflect工具类，所以我去看了一下，这篇文章写的不错推荐给大家一起看看，这篇文章讲述了Proxy和Reflect,并且描述了通过劫持对象的get或者set方法实现表单校验和请求拦截，扩展了我的编程思路。<br><a href="https://mp.weixin.qq.com/s/9Ve7iidl4V8I_Of3ek2EDQ">揭秘：Proxy 与 Reflect，为何总是形影不离</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>ref判断了对象是原始类型还是object，是object则通过reactive new Proxy后再赋值给value，否则直接赋值给value,ref支持声明number，布尔等原始类型的值和对象的响应式数据</li><li>reactive只支持声明object响应式数据，返回的是一个Proxy代理对象</li><li>通过Weak容器，实现观察者角色，ref和reactive都实现了通过get的track收集依赖到容器和set参数的trigger触发容易中的依赖的更新，下面是vue官方的一段话。</li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33bc34be57064e6585425a5bac7953d9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1033&h=324&s=60515&e=png&b=fefefe" alt="image.png"></p><p>最后，如果有写的不好的，欢迎大家指点。</p>]]></content>
    
    
    <summary type="html">vue2的响应式通过Object.defineProperty将data转为响应式，而vue3则通过Proxy实现，性能得到显著提升，那么vue3的响应式系统做了什么呢？发生了哪些变化？</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>HTML5总结</title>
    <link href="http://example.com/2020/02/23/HTML5%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2020/02/23/HTML5%E6%80%BB%E7%BB%93/</id>
    <published>2020-02-23T14:55:10.000Z</published>
    <updated>2024-06-15T11:00:00.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在了解HTML5之前，我们先来了解一下什么是HTML和HTML5</p><blockquote><p>HTML的全称为超文本标记语言(Hyper Text Markup Language)，是一种标记语言。它包括一系列标签，HTML标签可以说明文字，图形、动画、声音、表格、链接等，通过这些标签编写成一个让浏览器能识别的.html文件。它的版本发展历程为HTML 1.0  &gt;  HTML 2.0  &gt;  HTML 3.2  &gt;  HTML 4.0  &gt;  HTML 4.01</p></blockquote><blockquote><p>HTML5是由W3C(万维网联盟)在2007年成立的，旨在满足互联网应用迅速发展的需求，提供一个统一的、开放的网页标准，代表了网页标记语言的新标准，也标志着网页应用开发进入了一个新的时代，拥有比HTML更丰富的特性的同时，也废弃了一些标签特性。</p></blockquote><p>##HTML5的特性有那些？</p><ol><li>新增加了一些语义标签</li><li>增强型表单</li><li>视频和音频</li><li>Canvas绘图</li><li>SVG绘图</li><li>地理定位</li><li>拖拽API</li><li>WebWorker</li><li>WebStorage</li><li>WebSocket</li><li>移除部分标签</li></ol><h3 id="语义标签"><a href="#语义标签" class="headerlink" title="语义标签"></a>语义标签</h3><p>这些新的语义元素有助于更准确地描述文档的结构，提高文档的可读性和可访问性。使用这些元素有助于浏览器、搜索引擎和辅助技术更好地理解和解释页面内容，更有利于SEO优化，方便爬虫爬取网页，增加曝光度。</p><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>article</td><td>定义页面独立的内容区域</td></tr><tr><td>aside</td><td>定义页面的侧边栏内容</td></tr><tr><td>bdi</td><td>允许您设置一段文本，使其脱离其父元素的文本方向设置</td></tr><tr><td>details</td><td>用于描述文档或文档某个部分的细节</td></tr><tr><td>dialog</td><td>定义对话框，比如提示框</td></tr><tr><td>summary</td><td>标签包含details元素的标题</td></tr><tr><td>figure</td><td>规定独立的流内容（图像、图表、照片、代码等等）</td></tr><tr><td>figcaption</td><td>定义figure元素的标题</td></tr><tr><td>header</td><td>定义了文档的头部区域</td></tr><tr><td>footer</td><td>定义section或document的页脚</td></tr><tr><td>mark</td><td>定义带有记号的文本(实际是高亮文本内容)</td></tr><tr><td>meter</td><td>定义度量衡。仅用于已知最大和最小值的度量</td></tr><tr><td>nav</td><td>定义导航链接的部分</td></tr><tr><td>progress</td><td>定义任何类型的任务的进度</td></tr><tr><td>ruby</td><td>定义ruby注释（中文注音或字符）</td></tr><tr><td>rt</td><td>定义字符（中文注音或字符）的解释或发音</td></tr><tr><td>rp</td><td>在ruby注释中使用，定义不支持ruby元素的浏览器所显示的内容</td></tr><tr><td>section</td><td>定义文档中的节（section、区段）</td></tr><tr><td>time</td><td>定义日期或时间</td></tr><tr><td>wbr</td><td>规定在文本中的何处适合添加换行符</td></tr></tbody></table><pre><code class="html">&lt;!--用于表示页面中独立的、完整的、可以独立分配的内容。通常用于文章、博客帖子等--&gt;&lt;article&gt;     &lt;h2&gt;文章标题&lt;/h2&gt;     &lt;p&gt;文章内容...&lt;/p&gt; &lt;/article&gt;&lt;!--用于表示与页面内容相关的辅助信息。通常包含侧边栏、广告、引用等--&gt;&lt;aside&gt;     &lt;h2&gt;这里是侧边栏&lt;/h2&gt;     &lt;p&gt;相关链接...&lt;/p&gt; &lt;/aside&gt;&lt;!--用于设置大一号文字(最大7号)，并且可以设置文字方向(感觉这个没啥用)--&gt;&lt;p&gt;外面小一号文字&lt;big dir=&quot;rtl&quot;&gt;这是大一号的文本111。&lt;/big&gt;&lt;/p&gt;&lt;!--用于展示详情内容，和tree树结构类似--&gt;&lt;details&gt;&lt;summary&gt;显示的标题&lt;/summary&gt;&lt;p&gt; 折叠隐藏的内容1&lt;/p&gt;&lt;p&gt;折叠隐藏的内容2&lt;/p&gt;&lt;/details&gt;&lt;!--在页面中间展示一个窗口结构--&gt;&lt;dialog open&gt; 窗口内容&lt;/dialog&gt;&lt;!--在页面中规定独立的流内容（图像、图表、照片、代码等等）展示区域--&gt;&lt;figure&gt;  &lt;img src=&quot;xxx.img&quot; &gt;  &lt;figcaption&gt;这是一张图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;!--header规定页面的头部，footer规定页面的底部--&gt;&lt;header&gt;头部&lt;/header&gt;&lt;footer&gt;底部&lt;/footer&gt;&lt;!--mark内容会高亮--&gt;今天要&lt;mark&gt;吃鸡腿&lt;/mark&gt;&lt;!--类似一个进度条，展示设置的百分比值或者指定的max和value--&gt;&lt;meter value=&quot;2&quot; min=&quot;0&quot; max=&quot;10&quot;&gt;&lt;/meter&gt;&lt;meter value=&quot;0.6&quot;&gt;&lt;/meter&gt;用于包含导航链接的部分，通常包含页面的主导航&lt;nav&gt;     &lt;ul&gt;         &lt;li&gt;&lt;a href=&quot;/&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;         &lt;li&gt;&lt;a href=&quot;/&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt;         &lt;li&gt;&lt;a href=&quot;/&quot;&gt;联系我们&lt;/a&gt;&lt;/li&gt;     &lt;/ul&gt; &lt;/nav&gt;&lt;!--进度条，一般可以设置下载进度--&gt;&lt;progress value=&quot;22&quot; max=&quot;100&quot;&gt;&lt;/progress&gt;&lt;!--很方便的功能，标注，下面有运行效果--&gt;&lt;ruby&gt;  汉 &lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Han&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;  字 &lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Zi&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;&lt;!--如下是运行结果--&gt;Han  Zi汉   字&lt;!--定义了一个区域--&gt;&lt;section&gt;这是一个区域&lt;/section&gt;&lt;!--time标签不会在任何浏览器中呈现任何特殊效果，只是用来给机器识别的--&gt;&lt;!--该元素能够以机器可读的方式对日期和时间进行编码，这样，举例说，用户代理能够把生日提醒或排定的事件添加到用户日程表中，搜索引擎也能够生成更智能的搜索结果--&gt;&lt;p&gt;我今年的生日要&lt;time datetime=&quot;2024-06-01&quot;&gt;吃蛋糕&lt;/time&gt;&lt;/p&gt;&lt;!-与&lt;br&gt;标签不同，如果浏览器窗口的宽度足够，则不换行；反之，则在添加了 &lt;wbr&gt; 标签的位置进行换行--&gt;我要吃&lt;wbr&gt;麦当当&lt;/wbr&gt;</code></pre><p><code>ps:各个浏览器对语义标签的支持情况不一样，使用的时候建议去查阅一下对应的支持情况</code></p><h3 id="增强型表单"><a href="#增强型表单" class="headerlink" title="增强型表单"></a>增强型表单</h3><p>HTML5 拥有多个新的表单 Input 输入类型。这些新特性提供了更好的输入控制和验证</p><table><thead><tr><th>type</th><th>描述</th></tr></thead><tbody><tr><td>color</td><td>主要用于选取颜色</td></tr><tr><td>date</td><td>选取日期</td></tr><tr><td>datetime</td><td>选取日期(UTC时间)</td></tr><tr><td>datetime-local</td><td>选取日期（无时区）</td></tr><tr><td>month</td><td>选择一个月份</td></tr><tr><td>week</td><td>选择周和年</td></tr><tr><td>time</td><td>选择一个时间</td></tr><tr><td>email</td><td>包含e-mail地址的输入域</td></tr><tr><td>number</td><td>数值的输入域</td></tr><tr><td>url</td><td>url地址的输入域</td></tr><tr><td>tel</td><td>定义输入电话号码和字段</td></tr><tr><td>search</td><td>用于搜索域</td></tr><tr><td>range</td><td>一个范围内数字值的输入域</td></tr></tbody></table><p>HTML5 新增以下表单元素</p><table><thead><tr><th>表单元素</th><th>描述</th></tr></thead><tbody><tr><td>datalist</td><td>元素规定输入域的选项列表使用 input 元素的 list 属性与 datalist 元素的 id 绑定</td></tr><tr><td>keygen</td><td>提供一种验证用户的可靠方法标签规定用于表单的密钥对生成器字段。</td></tr><tr><td>output</td><td>用于不同类型的输出比如计算或脚本输出</td></tr></tbody></table><p>HTML5 新增的表单属性</p><table><thead><tr><th>表单属性</th><th>描述</th></tr></thead><tbody><tr><td>placehoder</td><td>输入框默认提示文字</td></tr><tr><td>required</td><td>要求输入的内容是否可为空</td></tr><tr><td>pattern</td><td>描述一个正则表达式验证输入的值</td></tr><tr><td>min</td><td>设置元素最小值</td></tr><tr><td>max</td><td>设置元素最大值</td></tr><tr><td>step</td><td>为输入域规定合法的数字间隔</td></tr><tr><td>heigh</td><td>用于image类型input标签图像高度</td></tr><tr><td>wdith</td><td>用于image类型input标签图像宽度</td></tr><tr><td>autofocus</td><td>规定在页面加载时，域自动获得焦点</td></tr><tr><td>multiple</td><td>规定input元素中可选择多个值</td></tr><tr><td>form</td><td>可以在form外部的input上面指向某个form，随着form一起提交，方便页面布局</td></tr><tr><td>formaction</td><td>用于描述表单提交的 URL 地址。会覆盖 form元素中的action属性</td></tr><tr><td>novalidate</td><td>布尔属性，在表单提交时无需被验证</td></tr><tr><td>autofocus</td><td>页面加载时自动聚焦到此表单控件</td></tr></tbody></table><h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><pre><code class="html">&lt;!--video定义视频播放器的容器--&gt;&lt;!--width 和 height：设置视频播放器的宽度和高度并且增加controls：向用户显示视频播放器的控制按钮--&gt;&lt;video width=&quot;300&quot; height=&quot;200&quot; controls&gt;    &lt;!--source定义多个媒体资源，浏览器将选择支持的第一个资源进行播放--&gt;    &lt;!--type支持video/mp4, video/webm, 和 video/ogg--&gt;    &lt;source src=&quot;a.mp4&quot; type=&quot;video/mp4&quot;&gt;    &lt;source src=&quot;b.mp4&quot; type=&quot;video/mp4&quot;&gt;    &lt;!--track字幕，可以定义多个--&gt;    &lt;!--kind规定文本轨道的文本类型--&gt;    &lt;!--srclang规定轨道文本数据的语言。如果 kind 属性值是 &quot;subtitles&quot;，则该属性是必需的--&gt;    &lt;!--src文件资源，label规定文本轨道的标签和标题--&gt;    &lt;track src=&quot;a.vtt&quot; kind=&quot;subtitles&quot; srclang=&quot;en&quot; label=&quot;标题&quot;/&gt;    &lt;track src=&quot;b.vtt&quot; kind=&quot;subtitles&quot; srclang=&quot;en&quot; label=&quot;标题&quot;/&gt;&lt;/video&gt;</code></pre><p>视频文件类型各个浏览器支持情况</p><table><thead><tr><th>浏览器</th><th>MP4</th><th>WebM</th><th>Ogg</th></tr></thead><tbody><tr><td>Internet Explorer 9+</td><td>YES</td><td>NO</td><td>NO</td></tr><tr><td>Chrome 6+</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>Firefox 3.6+</td><td>NO</td><td>YES</td><td>YES</td></tr><tr><td>Safari 5+</td><td>YES</td><td>NO</td><td>NO</td></tr><tr><td>Opera 10.6+</td><td>NO</td><td>YES</td><td>YES</td></tr></tbody></table><h3 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h3><pre><code class="html">&lt;!---   autoplay指定音频或视频在页面加载时自动播放--&gt;&lt;!---   loop指定音频或视频在播放结束后是否循环播放--&gt;&lt;!---   preload指定是否在页面加载时预加载音频或视频，可设置为 &quot;auto&quot;、&quot;metadata&quot; 或 &quot;none&quot;--&gt;&lt;audio controls autoplay loop preload=&quot;auto&quot;&gt;    &lt;source src=&quot;horse.ogg&quot; type=&quot;audio/ogg&quot;&gt;    &lt;source src=&quot;horse.mp3&quot; type=&quot;audio/mpeg&quot;&gt;    &lt;source src=&quot;horse.mp3&quot; type=&quot;audio/wav&quot;&gt; &lt;/audio&gt;</code></pre><p><code>ps:音频和视频都有autoplay、loop、preload属性</code></p><p>音频文件类型各个浏览器支持情况</p><table><thead><tr><th>浏览器</th><th>MP3</th><th>Wav</th><th>Ogg</th></tr></thead><tbody><tr><td>Internet Explorer</td><td>YES</td><td>NO</td><td>NO</td></tr><tr><td>Chrome</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>Firefox</td><td>YES</td><td>YES</td><td>YES</td></tr><tr><td>Safari</td><td>YES</td><td>YES</td><td>NO</td></tr><tr><td>Opera</td><td>YES</td><td>YES</td><td>YES</td></tr></tbody></table><h3 id="Canvas绘图"><a href="#Canvas绘图" class="headerlink" title="Canvas绘图"></a>Canvas绘图</h3><p>一般用于组合图片，或者在图片上绘制文字，生成二维码，绘制动画效果等，下面是一个简单的例子</p><pre><code class="html">&lt;!--定义一个空白的画布--&gt;&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot; style=&quot;border:1px solid red;&quot;&gt;&lt;/canvas&gt;&lt;script&gt;// 获取Canvas元素的上下文    const canvas = document.getElementById(&#39;myCanvas&#39;);//通过id获取canvas对象    const ctx = canvas.getContext(&#39;2d&#39;);//获取2D上下文，用于进行绘图操作    // 绘制矩形    ctx.fillStyle = &#39;green&#39;;//设置填充颜色    ctx.fillRect(10, 10, 150, 80);//fillRect(x, y, width, height)绘制填充的矩形    // 绘制文本    ctx.fillStyle = &#39;white&#39;;//设置填充颜色    ctx.font = &#39;20px Arial&#39;;//设置字体样式    ctx.fillText(&#39;我要吃烤鸭!&#39;, 20, 50);//fillText(text, x, y)在画布上绘制填充文本    // 绘制路径（三角形）    ctx.beginPath();//创建一条路径    ctx.moveTo(10, 80);//moveTo(x, y)创建指定一个坐标    ctx.lineTo(85, 10);//lineTo(x，y)绘制一条从当前点到指定坐标的直线    ctx.lineTo(160, 80);    ctx.closePath();//闭合路径，连接起点和终点    ctx.stroke();//绘制路径的边框&lt;/script&gt;</code></pre><h3 id="SVG绘图"><a href="#SVG绘图" class="headerlink" title="SVG绘图"></a>SVG绘图</h3><pre><code class="html">&lt;svg&gt;  &lt;ellipse cx=&quot;150&quot; cy=&quot;80&quot; rx=&quot;100&quot; ry=&quot;50&quot; style=&quot;fill:yellow;stroke:purple;stroke-width:2&quot; /&gt;&lt;/svg&gt;</code></pre><p>ps：svgs是W3C推荐标准，优点有如下几个（可能不全），都是我印象中的，更多的svg内容可以参考<a href="https://www.w3cschool.cn/svg/svg-tutorial.html">svg教程</a>学习，我平时都是要求ui给出svg图片。 </p><blockquote><p>图像在放大或改变尺寸的情况下其图形质量不会有所损失</p><p>使用 XML 格式定义图形,内容更容易被搜索和识别。</p><p>相对png之类的可以更好的被压缩</p></blockquote><h3 id="地理定位Geolocation"><a href="#地理定位Geolocation" class="headerlink" title="地理定位Geolocation"></a>地理定位Geolocation</h3><pre><code class="html">//geolocation对象的3个方法//window.navigator.geolocation &#123; //    getCurrentPosition: fn //用于获取当前的位置数据 //    watchPosition: fn //监视用户位置的改变 //    clearWatch: fn //清除定位监视//&#125;　&lt;p id=&quot;demo&quot;&gt;点击按钮获取您当前坐标（可能需要比较长的时间获取）：&lt;/p&gt;&lt;button onclick=&quot;getLocation()&quot;&gt;点我&lt;/button&gt;&lt;script&gt;var x=document.getElementById(&quot;demo&quot;);function getLocation()&#123;  let success = (position)=&gt;&#123;       console.log(&#39;定位时间：&#39;,position.timestamp)　　　　console.log(&#39;经度：&#39;,position.coords.longitude)　　　　console.log(&#39;纬度：&#39;,position.coords.latitude)　　　　console.log(&#39;海拔：&#39;,position.coords.altitude)　　　　console.log(&#39;速度：&#39;,position.coords.speed)  &#125;  let error = (error)=&gt;&#123;      switch(error.code) &#123;        case error.PERMISSION_DENIED:          x.innerHTML=&quot;用户拒绝对获取地理位置的请求。&quot;          break;        case error.POSITION_UNAVAILABLE:          x.innerHTML=&quot;位置信息是不可用的。&quot;          break;        case error.TIMEOUT:          x.innerHTML=&quot;请求用户地理位置超时。&quot;          break;        case error.UNKNOWN_ERROR:          x.innerHTML=&quot;未知错误。&quot;          break;       &#125;  &#125;  navigator.geolocation ? navigator.geolocation.getCurrentPosition(success,error):(x.innerHTML=&quot;Geolocation is not supported by this browser.&quot;)&#125;&lt;/script&gt;</code></pre><h3 id="拖拽API"><a href="#拖拽API" class="headerlink" title="拖拽API"></a>拖拽API</h3><pre><code class="html">&lt;p&gt;拖动红色div到矩形中:&lt;/p&gt;&lt;!--ondrop监听拖动结束事件--&gt;&lt;div id=&quot;div1&quot; style=&quot;width:350px;height:70px;padding:10px;border:1px solid #aaaaaa;&quot; ondrop=&quot;drop(event)&quot; ondragover=&quot;allowDrop(event)&quot;&gt;&lt;/div&gt;&lt;br&gt;&lt;!--draggable开启可被拖动,ondragstart监听拖拽开始事件--&gt;&lt;div id=&quot;drag1&quot; style=&quot;background:red;&quot; draggable=&quot;true&quot; ondragstart=&quot;drag(event)&quot;&gt;今天吃了大份的猪脚饭啊&lt;/div&gt;&lt;script&gt;function allowDrop(ev)&#123;    ev.preventDefault();&#125;function drag(ev)&#123;    ev.dataTransfer.setData(&quot;Text&quot;,ev.target.id);&#125;function drop(ev)&#123;    ev.preventDefault();    var data=ev.dataTransfer.getData(&quot;Text&quot;);    ev.target.appendChild(document.getElementById(data));&#125;&lt;/script&gt;</code></pre><p>拖拽API事件</p><table><thead><tr><th>拖动生命周期</th><th>属性名</th><th>描述</th></tr></thead><tbody><tr><td>拖动开始</td><td>ondragstart</td><td>在拖动操作开始时执行脚本</td></tr><tr><td>拖动过程中</td><td>ondrag</td><td>只要脚本在被拖动就运行脚本</td></tr><tr><td>拖动过程中</td><td>ondragenter</td><td>当元素被拖动到一个合法的防止目标时，执行脚本</td></tr><tr><td>拖动过程中</td><td>ondragover</td><td>只要元素正在合法的防止目标上拖动时，就执行脚本</td></tr><tr><td>拖动过程中</td><td>ondragleave</td><td>当元素离开合法的防止目标时，就执行脚本</td></tr><tr><td>拖动结束</td><td>ondrop</td><td>将被拖动元素放在目标元素内时运行脚本</td></tr><tr><td>拖动结束</td><td>ondragend</td><td>在拖动操作结束时运行脚本</td></tr></tbody></table><h3 id="WebWorker"><a href="#WebWorker" class="headerlink" title="WebWorker"></a>WebWorker</h3><p>web worker 是运行在后台的非阻塞性质的 JavaScript，不会影响页面的性能，更好的解释是，你可以使用web worker提供的一种简单的方法来为web内容在后台线程中运行脚本，这些线程在执行任务的过程中并不会干扰用户界面，并且这个worker的数量是有上限的一般取决于cpu的内核数量如果是8核cpu，那最多就创建8个最佳，否则也是会影响性能的。<br>主要优势是</p><ul><li><p><strong>并行处理</strong>：可以同时执行多个任务，而不会相互阻塞，特别是在多核CPU上。</p></li><li><p><strong>性能提升</strong>：对于密集型任务，Web Workers可以提高应用程序的整体性能和响应速度。</p></li><li><p><strong>用户体验改善</strong>：主线程（通常是UI线程）不会因为需要执行复杂计算而被阻塞，因此应用程序仍然可以响应用户操作。</p></li></ul><pre><code class="ts">//work.jsvar i=0; function timedCount()&#123;      i=i+1;      postMessage(i); //通过 postMessage发送结果到前端（比如下载进度百分比，上传进度百分比等）    let time = setTimeout(()=&gt;&#123;    time = null    timedCount()    &#125;,500);  &#125;  timedCount();//使用的时候let works_a=new Worker(&quot;demo_workers.js&quot;);let works_b=new Worker(&quot;demo_workers.js&quot;);works.onmessage = function (event) &#123;     //接收Worker的回传信息    console.log(event.data)&#125;//停止worksworks.terminate();</code></pre><h3 id="WebStorage离线存储"><a href="#WebStorage离线存储" class="headerlink" title="WebStorage离线存储"></a>WebStorage离线存储</h3><p>离线存储允许web应用在用户的设备上本地保存数据，这样即使在没有网络连接的情况下，用户也能加载和使用应用。离线存储的目的是提高应用的性能和可用性，得到更好的用户体验。目前常用的有LocalStorage、SessionStorage和IndexedDB、Cookie</p><h4 id="LocalStorage、SessionStorage、IndexedDB、Cookie的区别"><a href="#LocalStorage、SessionStorage、IndexedDB、Cookie的区别" class="headerlink" title="LocalStorage、SessionStorage、IndexedDB、Cookie的区别"></a>LocalStorage、SessionStorage、IndexedDB、Cookie的区别</h4><ol><li><p><strong>LocalStorage</strong>:</p><ul><li>用于长期存储数据，数据没有过期时间，除非主动删除数据，否则数据永远不会消失。</li><li>存储容量较大，一般在5MB左右。</li><li>只能存储字符串，因此需要将对象JSON序列化。</li></ul></li><li><p><strong>SessionStorage</strong>:</p><ul><li>用于临时存储数据，数据仅在页面会话期间存在，页面关闭则数据消失。</li><li>和 LocalStorage 类似，但它的作用域限于单个页面会话。</li><li>存储容量和 LocalStorage 相似，也主要用于存储字符串数据。</li></ul></li><li><p><strong>IndexedDB</strong>:</p><ul><li>是一个低级API用于客户端存储大量结构化数据，包括文件&#x2F;二进制大对象。</li><li>支持事务，可以存储和操作大量数据。</li><li>存储容量比 LocalStorage 和 SessionStorage 大得多。</li><li>允许你创建索引来高效查询数据。</li></ul></li><li><p><strong>Cookie</strong>:</p><ul><li>按照域名存储，你在哪一个域名下存储的内容, 就在哪一个域名下使用， 其他域名都用不了， 和资源路径地址没有关系。</li><li>存储大小有限制，4KB 左右或者50 条左右。</li><li>时效性，默认是会话级别的时效性(关闭浏览器就没有了)，可以手动设置。</li><li>请求自动携带，当你的 cookie 空间里面有内容的时候，只要是当前域名下的任意一个请求, 都会自动携带 cookie 放在请求头里面， cookie 里面有多少自动携带多少，没有就不会携带了。</li><li>安全性不高，不建议存储敏感数据<br>示例</li></ul></li></ol><pre><code class="html">&lt;!-- 保存设置按钮 --&gt; &lt;button onclick=&quot;saveSettings()&quot;&gt;保存到LocalStorage&lt;/button&gt;&lt;button onclick=&quot;saveSessionSettings()&quot;&gt;保存到SessionStorage&lt;/button&gt;&lt;button onclick=&quot;saveIndexedDBSettings()&quot;&gt;保存到IndexedDB&lt;/button&gt;&lt;!-- 读取设置按钮 --&gt; &lt;button onclick=&quot;loadSettings()&quot;&gt;从LocalStorage读取&lt;/button&gt;&lt;button onclick=&quot;loadSessionSettings()&quot;&gt;从SessionStorage读取&lt;/button&gt;&lt;button onclick=&quot;loadIndexedDBSettings()&quot;&gt;从IndexedDB读取&lt;/button&gt;&lt;!-- 显示设置的区域 --&gt; &lt;div id=&quot;settings&quot;&gt;&lt;/div&gt; &lt;script&gt; // LocalStorage 示例 function saveSettings() &#123; // 保存设置到LocalStorage      localStorage.setItem(&#39;favoriteChampion&#39;, &#39;炸鸡&#39;);    localStorage.setItem(&#39;resolution&#39;, &#39;烤串&#39;);    console.log(&#39;设置已保存到LocalStorage&#39;); &#125; function loadSettings() &#123;    // 从LocalStorage读取设置     const favoriteChampion = localStorage.getItem(&#39;favoriteChampion&#39;);    const resolution = localStorage.getItem(&#39;resolution&#39;);     document.getElementById(&#39;settings&#39;).innerText = `LocalStorage - 最喜欢的食物是: $&#123;favoriteChampion&#125;和 $&#123;resolution&#125;`;    console.log(&#39;从LocalStorage读取设置&#39;);&#125; // SessionStorage 示例 function saveSessionSettings() &#123; // 保存设置到SessionStorage    sessionStorage.setItem(&#39;sessionFavoriteChampion&#39;, &#39;薯条&#39;);     sessionStorage.setItem(&#39;sessionResolution&#39;, &#39;汉堡&#39;);    console.log(&#39;会话设置已保存到SessionStorage&#39;); &#125; function loadSessionSettings() &#123; // 从SessionStorage读取设置     const sessionFavoriteChampion = sessionStorage.getItem(&#39;sessionFavoriteChampion&#39;);     const sessionResolution = sessionStorage.getItem(&#39;sessionResolution&#39;);     document.getElementById(&#39;settings&#39;).innerText = `SessionStorage - 最喜欢的食物是: $&#123;sessionFavoriteChampion&#125;和 $&#123;sessionResolution&#125;`;     console.log(&#39;从SessionStorage读取设置&#39;); &#125; // IndexedDB 示例 var db; // 打开数据库 var request = indexedDB.open(&#39;LoLSettingsDB&#39;, 1); request.onerror = function(event) &#123; // 处理打开数据库时的错误     console.log(&#39;打开IndexedDB时发生错误。&#39;);&#125;; request.onupgradeneeded = function(event) &#123; // 数据库升级或首次创建时执行    db = event.target.result;     if (!db.objectStoreNames.contains(&#39;settings&#39;)) &#123;         var objectStore = db.createObjectStore(&#39;settings&#39;, &#123; keyPath: &#39;id&#39; &#125;);         objectStore.createIndex(&#39;favoriteChampion&#39;, &#39;favoriteChampion&#39;, &#123; unique: false &#125;);         objectStore.createIndex(&#39;resolution&#39;, &#39;resolution&#39;, &#123; unique: false &#125;);     &#125;&#125;; request.onsuccess = function(event) &#123; // 成功打开数据库     db = event.target.result;     console.log(&#39;IndexedDB成功打开&#39;); &#125;; function saveIndexedDBSettings() &#123; // 保存设置到IndexedDB     var transaction = db.transaction([&#39;settings&#39;], &#39;readwrite&#39;);    var objectStore = transaction.objectStore(&#39;settings&#39;);    var userSettings = &#123; id: &#39;food&#39;, favoriteChampion: &#39;鸡腿&#39;, resolution: &#39;鸭腿&#39; &#125;;     var request = objectStore.put(userSettings);     request.onsuccess = function(event) &#123;         console.log(&#39;食物设置已保存到IndexedDB&#39;);    &#125;;     request.onerror = function(event) &#123;         console.log(&#39;保存设置到IndexedDB时发生错误&#39;);     &#125;; &#125;function loadIndexedDBSettings() &#123; // 从IndexedDB读取设置     var transaction = db.transaction([&#39;settings&#39;]);     var objectStore = transaction.objectStore(&#39;settings&#39;);     var request = objectStore.get(&#39;food&#39;);     request.onsuccess = function(event) &#123;         if (request.result) &#123;             document.getElementById(&#39;settings&#39;).innerText = `IndexedDB - 最喜欢的食物是: $&#123;request.result.favoriteChampion&#125;和 $&#123;request.result.resolution&#125;`;             console.log(&#39;从IndexedDB读取食物设置&#39;);         &#125; else &#123;             console.log(&#39;在IndexedDB中未找到食物设置&#39;);        &#125;    &#125;;     request.onerror = function(event) &#123;         console.log(&#39;从IndexedDB读取时发生错误&#39;);    &#125;; &#125;&lt;/script&gt;</code></pre><h3 id="WebSocket长连接"><a href="#WebSocket长连接" class="headerlink" title="WebSocket长连接"></a>WebSocket长连接</h3><p>WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p><pre><code class="ts">//web_socket_utils.js export const WebSocketTest =(call_back)=&gt;&#123;    if (&quot;WebSocket&quot; in window)&#123;       //浏览器支持 WebSocket 打开一个 web socket       const ws = new WebSocket(&quot;ws://localhost:9998/echo&quot;);       ws.onopen = function()       &#123;          // Web Socket 已连接上，使用 send() 方法发送数据          ws.send(&quot;发送数据&quot;);       &#125;;       ws.onmessage = function (evt)        &#123;           call_back(evt.data)       &#125;;        ws.error = function (evt)        &#123;           call_back(evt.data)       &#125;;       ws.onclose = function()       &#123;           // 关闭 websocket       &#125;;       ws.onopen()    &#125;else&#123;       // 浏览器不支持 WebSocket    &#125; &#125; //使用WebSocketTest的时候 import &#123;WebSocketTest&#125; from &#39;./web_socket_utils&#39; let get_server_data = (data)=&gt;&#123;     //socket返回的数据data &#125;  WebSocketTest(get_server_data)</code></pre><h3 id="HTML5移除的标签"><a href="#HTML5移除的标签" class="headerlink" title="HTML5移除的标签"></a>HTML5移除的标签</h3><p>1.样式标签：不再推荐使用一些样式标签，如<code>&lt;big&gt;</code>、<code>&lt;basefont&gt;</code>、<code>&lt;big&gt;</code>、<code>&lt;center&gt;</code>、<code>&lt;font&gt;</code>、<code>&lt;s&gt;</code>、<code>&lt;tt&gt;</code>、<code>&lt;u&gt;</code>、<code>&lt;strike&gt;</code>等，应使用CSS来设置样式。</p><p>2.部分浏览器支持的元素:<code>&lt;applet&gt;</code>、<code>&lt;bgsound&gt;</code>、<code>&lt;blink&gt;</code>、<code>&lt;marquee&gt;</code>、<code>&lt;object&gt;</code>：HTML5不再推荐使用<code>&lt;applet&gt;</code>和<code>&lt;object&gt;</code>标签来嵌入Java小程序或其他外部插件，而是鼓励使用<code>&lt;embed&gt;</code>、<code>&lt;video&gt;</code>、<code>&lt;audio&gt;</code>等标签。</p><p>3.对可用性产生负面影响:<code>&lt;frameset&gt;</code>、<code>&lt;frame&gt;</code>、<code>&lt;noframes&gt;</code>：html5中不支持frame框架，只支持iframe框架，推荐使用<code>&lt;iframe&gt;</code>或其他技术来实现相同效果。</p><ol start="4"><li>其他标签：</li></ol><ul><li>废除<code>&lt;menu&gt;</code>标签，推荐使用无序列表<code>&lt;ul&gt;</code>替代</li><li>废除<code>&lt;rb&gt;</code>，使用<code>&lt;ruby&gt;</code>替代</li><li>废除<code>&lt;acronym&gt;</code>使用<code>&lt;abbr&gt;</code>替代</li><li>废除<code>&lt;dir&gt;</code>使用<code>&lt;ul&gt;</code>替代</li><li>废除<code>&lt;isindex&gt;</code>使用<code>&lt;form&gt;</code>与<code>&lt;input&gt;</code>相结合的方式替代</li><li>废除<code>&lt;listing&gt;</code>使用<code>&lt;pre&gt;</code>替代</li><li>废除<code>&lt;xmp&gt;</code>使用<code>&lt;code&gt;</code>替代</li><li>废除<code>&lt;nextid&gt;</code>使用<code>&lt;guids&gt;</code>替代</li><li>废除<code>&lt;plaintex&gt;</code>使用“text&#x2F;plian”（无格式正文）MIME类型替代</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>梳理了HTML5的知识点，如果有不对的地方也希望大家指正。</p>]]></content>
    
    
    <summary type="html">什么是HTML和HTML5</summary>
    
    
    
    
  </entry>
  
</feed>
