
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>HTML5总结 | 木子的博客</title>
    <meta name="author" content="lish" />
    <meta name="description" content="--是木子呀" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<!-- <link rel="stylesheet" href="/source/css/prism.css">
<script src="/source/js/prism.js" async></script> -->
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="木子的博客" type="application/atom+xml">
</head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>木子的博客</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;木子的博客</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>HTML5总结</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2020/2/23
        </span>
        
        
    </div>
    
    <div class="content" v-pre>
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在了解HTML5之前，我们先来了解一下什么是HTML和HTML5</p>
<blockquote>
<p>HTML的全称为超文本标记语言(Hyper Text Markup Language)，是一种标记语言。它包括一系列标签，HTML标签可以说明文字，图形、动画、声音、表格、链接等，通过这些标签编写成一个让浏览器能识别的.html文件。它的版本发展历程为HTML 1.0  &gt;  HTML 2.0  &gt;  HTML 3.2  &gt;  HTML 4.0  &gt;  HTML 4.01</p>
</blockquote>
<blockquote>
<p>HTML5是由W3C(万维网联盟)在2007年成立的，旨在满足互联网应用迅速发展的需求，提供一个统一的、开放的网页标准，代表了网页标记语言的新标准，也标志着网页应用开发进入了一个新的时代，拥有比HTML更丰富的特性的同时，也废弃了一些标签特性。</p>
</blockquote>
<p>##HTML5的特性有那些？</p>
<ol>
<li>新增加了一些语义标签</li>
<li>增强型表单</li>
<li>视频和音频</li>
<li>Canvas绘图</li>
<li>SVG绘图</li>
<li>地理定位</li>
<li>拖拽API</li>
<li>WebWorker</li>
<li>WebStorage</li>
<li>WebSocket</li>
<li>移除部分标签</li>
</ol>
<h3 id="语义标签"><a href="#语义标签" class="headerlink" title="语义标签"></a>语义标签</h3><p>这些新的语义元素有助于更准确地描述文档的结构，提高文档的可读性和可访问性。使用这些元素有助于浏览器、搜索引擎和辅助技术更好地理解和解释页面内容，更有利于SEO优化，方便爬虫爬取网页，增加曝光度。</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>article</td>
<td>定义页面独立的内容区域</td>
</tr>
<tr>
<td>aside</td>
<td>定义页面的侧边栏内容</td>
</tr>
<tr>
<td>bdi</td>
<td>允许您设置一段文本，使其脱离其父元素的文本方向设置</td>
</tr>
<tr>
<td>details</td>
<td>用于描述文档或文档某个部分的细节</td>
</tr>
<tr>
<td>dialog</td>
<td>定义对话框，比如提示框</td>
</tr>
<tr>
<td>summary</td>
<td>标签包含details元素的标题</td>
</tr>
<tr>
<td>figure</td>
<td>规定独立的流内容（图像、图表、照片、代码等等）</td>
</tr>
<tr>
<td>figcaption</td>
<td>定义figure元素的标题</td>
</tr>
<tr>
<td>header</td>
<td>定义了文档的头部区域</td>
</tr>
<tr>
<td>footer</td>
<td>定义section或document的页脚</td>
</tr>
<tr>
<td>mark</td>
<td>定义带有记号的文本(实际是高亮文本内容)</td>
</tr>
<tr>
<td>meter</td>
<td>定义度量衡。仅用于已知最大和最小值的度量</td>
</tr>
<tr>
<td>nav</td>
<td>定义导航链接的部分</td>
</tr>
<tr>
<td>progress</td>
<td>定义任何类型的任务的进度</td>
</tr>
<tr>
<td>ruby</td>
<td>定义ruby注释（中文注音或字符）</td>
</tr>
<tr>
<td>rt</td>
<td>定义字符（中文注音或字符）的解释或发音</td>
</tr>
<tr>
<td>rp</td>
<td>在ruby注释中使用，定义不支持ruby元素的浏览器所显示的内容</td>
</tr>
<tr>
<td>section</td>
<td>定义文档中的节（section、区段）</td>
</tr>
<tr>
<td>time</td>
<td>定义日期或时间</td>
</tr>
<tr>
<td>wbr</td>
<td>规定在文本中的何处适合添加换行符</td>
</tr>
</tbody></table>
<pre><code class="html">&lt;!--用于表示页面中独立的、完整的、可以独立分配的内容。通常用于文章、博客帖子等--&gt;
&lt;article&gt; 
    &lt;h2&gt;文章标题&lt;/h2&gt; 
    &lt;p&gt;文章内容...&lt;/p&gt; 
&lt;/article&gt;
&lt;!--用于表示与页面内容相关的辅助信息。通常包含侧边栏、广告、引用等--&gt;
&lt;aside&gt; 
    &lt;h2&gt;这里是侧边栏&lt;/h2&gt; 
    &lt;p&gt;相关链接...&lt;/p&gt; 
&lt;/aside&gt;
&lt;!--用于设置大一号文字(最大7号)，并且可以设置文字方向(感觉这个没啥用)--&gt;
&lt;p&gt;外面小一号文字&lt;big dir=&quot;rtl&quot;&gt;这是大一号的文本111。&lt;/big&gt;&lt;/p&gt;
&lt;!--用于展示详情内容，和tree树结构类似--&gt;
&lt;details&gt;
&lt;summary&gt;显示的标题&lt;/summary&gt;
&lt;p&gt; 折叠隐藏的内容1&lt;/p&gt;
&lt;p&gt;折叠隐藏的内容2&lt;/p&gt;
&lt;/details&gt;
&lt;!--在页面中间展示一个窗口结构--&gt;
&lt;dialog open&gt; 窗口内容&lt;/dialog&gt;
&lt;!--在页面中规定独立的流内容（图像、图表、照片、代码等等）展示区域--&gt;
&lt;figure&gt;
  &lt;img src=&quot;xxx.img&quot; &gt;
  &lt;figcaption&gt;这是一张图片&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;!--header规定页面的头部，footer规定页面的底部--&gt;
&lt;header&gt;头部&lt;/header&gt;
&lt;footer&gt;底部&lt;/footer&gt;
&lt;!--mark内容会高亮--&gt;
今天要&lt;mark&gt;吃鸡腿&lt;/mark&gt;
&lt;!--类似一个进度条，展示设置的百分比值或者指定的max和value--&gt;
&lt;meter value=&quot;2&quot; min=&quot;0&quot; max=&quot;10&quot;&gt;&lt;/meter&gt;
&lt;meter value=&quot;0.6&quot;&gt;&lt;/meter&gt;
用于包含导航链接的部分，通常包含页面的主导航
&lt;nav&gt; 
    &lt;ul&gt; 
        &lt;li&gt;&lt;a href=&quot;/&quot;&gt;首页&lt;/a&gt;&lt;/li&gt; 
        &lt;li&gt;&lt;a href=&quot;/&quot;&gt;关于我们&lt;/a&gt;&lt;/li&gt; 
        &lt;li&gt;&lt;a href=&quot;/&quot;&gt;联系我们&lt;/a&gt;&lt;/li&gt; 
    &lt;/ul&gt; 
&lt;/nav&gt;
&lt;!--进度条，一般可以设置下载进度--&gt;
&lt;progress value=&quot;22&quot; max=&quot;100&quot;&gt;&lt;/progress&gt;
&lt;!--很方便的功能，标注，下面有运行效果--&gt;
&lt;ruby&gt;
  汉 &lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Han&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;
  字 &lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;Zi&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;
&lt;/ruby&gt;
&lt;!--如下是运行结果--&gt;
Han  Zi
汉   字

&lt;!--定义了一个区域--&gt;
&lt;section&gt;这是一个区域&lt;/section&gt;
&lt;!--time标签不会在任何浏览器中呈现任何特殊效果，只是用来给机器识别的--&gt;
&lt;!--该元素能够以机器可读的方式对日期和时间进行编码，这样，举例说，用户代理能够把生日提醒或排定的事件添加到用户日程表中，搜索引擎也能够生成更智能的搜索结果--&gt;
&lt;p&gt;我今年的生日要&lt;time datetime=&quot;2024-06-01&quot;&gt;吃蛋糕&lt;/time&gt;&lt;/p&gt;
&lt;!-与&lt;br&gt;标签不同，如果浏览器窗口的宽度足够，则不换行；反之，则在添加了 &lt;wbr&gt; 标签的位置进行换行--&gt;
我要吃&lt;wbr&gt;麦当当&lt;/wbr&gt;
</code></pre>
<p><code>ps:各个浏览器对语义标签的支持情况不一样，使用的时候建议去查阅一下对应的支持情况</code></p>
<h3 id="增强型表单"><a href="#增强型表单" class="headerlink" title="增强型表单"></a>增强型表单</h3><p>HTML5 拥有多个新的表单 Input 输入类型。这些新特性提供了更好的输入控制和验证</p>
<table>
<thead>
<tr>
<th>type</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>color</td>
<td>主要用于选取颜色</td>
</tr>
<tr>
<td>date</td>
<td>选取日期</td>
</tr>
<tr>
<td>datetime</td>
<td>选取日期(UTC时间)</td>
</tr>
<tr>
<td>datetime-local</td>
<td>选取日期（无时区）</td>
</tr>
<tr>
<td>month</td>
<td>选择一个月份</td>
</tr>
<tr>
<td>week</td>
<td>选择周和年</td>
</tr>
<tr>
<td>time</td>
<td>选择一个时间</td>
</tr>
<tr>
<td>email</td>
<td>包含e-mail地址的输入域</td>
</tr>
<tr>
<td>number</td>
<td>数值的输入域</td>
</tr>
<tr>
<td>url</td>
<td>url地址的输入域</td>
</tr>
<tr>
<td>tel</td>
<td>定义输入电话号码和字段</td>
</tr>
<tr>
<td>search</td>
<td>用于搜索域</td>
</tr>
<tr>
<td>range</td>
<td>一个范围内数字值的输入域</td>
</tr>
</tbody></table>
<p>HTML5 新增以下表单元素</p>
<table>
<thead>
<tr>
<th>表单元素</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>datalist</td>
<td>元素规定输入域的选项列表使用 input 元素的 list 属性与 datalist 元素的 id 绑定</td>
</tr>
<tr>
<td>keygen</td>
<td>提供一种验证用户的可靠方法标签规定用于表单的密钥对生成器字段。</td>
</tr>
<tr>
<td>output</td>
<td>用于不同类型的输出比如计算或脚本输出</td>
</tr>
</tbody></table>
<p>HTML5 新增的表单属性</p>
<table>
<thead>
<tr>
<th>表单属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>placehoder</td>
<td>输入框默认提示文字</td>
</tr>
<tr>
<td>required</td>
<td>要求输入的内容是否可为空</td>
</tr>
<tr>
<td>pattern</td>
<td>描述一个正则表达式验证输入的值</td>
</tr>
<tr>
<td>min</td>
<td>设置元素最小值</td>
</tr>
<tr>
<td>max</td>
<td>设置元素最大值</td>
</tr>
<tr>
<td>step</td>
<td>为输入域规定合法的数字间隔</td>
</tr>
<tr>
<td>heigh</td>
<td>用于image类型input标签图像高度</td>
</tr>
<tr>
<td>wdith</td>
<td>用于image类型input标签图像宽度</td>
</tr>
<tr>
<td>autofocus</td>
<td>规定在页面加载时，域自动获得焦点</td>
</tr>
<tr>
<td>multiple</td>
<td>规定input元素中可选择多个值</td>
</tr>
<tr>
<td>form</td>
<td>可以在form外部的input上面指向某个form，随着form一起提交，方便页面布局</td>
</tr>
<tr>
<td>formaction</td>
<td>用于描述表单提交的 URL 地址。会覆盖 form元素中的action属性</td>
</tr>
<tr>
<td>novalidate</td>
<td>布尔属性，在表单提交时无需被验证</td>
</tr>
<tr>
<td>autofocus</td>
<td>页面加载时自动聚焦到此表单控件</td>
</tr>
</tbody></table>
<h3 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h3><pre><code class="html">&lt;!--video定义视频播放器的容器--&gt;
&lt;!--width 和 height：设置视频播放器的宽度和高度并且增加controls：向用户显示视频播放器的控制按钮--&gt;
&lt;video width=&quot;300&quot; height=&quot;200&quot; controls&gt;
    &lt;!--source定义多个媒体资源，浏览器将选择支持的第一个资源进行播放--&gt;
    &lt;!--type支持video/mp4, video/webm, 和 video/ogg--&gt;
    &lt;source src=&quot;a.mp4&quot; type=&quot;video/mp4&quot;&gt;
    &lt;source src=&quot;b.mp4&quot; type=&quot;video/mp4&quot;&gt;
    &lt;!--track字幕，可以定义多个--&gt;
    &lt;!--kind规定文本轨道的文本类型--&gt;
    &lt;!--srclang规定轨道文本数据的语言。如果 kind 属性值是 &quot;subtitles&quot;，则该属性是必需的--&gt;
    &lt;!--src文件资源，label规定文本轨道的标签和标题--&gt;
    &lt;track src=&quot;a.vtt&quot; kind=&quot;subtitles&quot; srclang=&quot;en&quot; label=&quot;标题&quot;/&gt;
    &lt;track src=&quot;b.vtt&quot; kind=&quot;subtitles&quot; srclang=&quot;en&quot; label=&quot;标题&quot;/&gt;
&lt;/video&gt;
</code></pre>
<p>视频文件类型各个浏览器支持情况</p>
<table>
<thead>
<tr>
<th>浏览器</th>
<th>MP4</th>
<th>WebM</th>
<th>Ogg</th>
</tr>
</thead>
<tbody><tr>
<td>Internet Explorer 9+</td>
<td>YES</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr>
<td>Chrome 6+</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>Firefox 3.6+</td>
<td>NO</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>Safari 5+</td>
<td>YES</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr>
<td>Opera 10.6+</td>
<td>NO</td>
<td>YES</td>
<td>YES</td>
</tr>
</tbody></table>
<h3 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h3><pre><code class="html">&lt;!---   autoplay指定音频或视频在页面加载时自动播放--&gt;
&lt;!---   loop指定音频或视频在播放结束后是否循环播放--&gt;
&lt;!---   preload指定是否在页面加载时预加载音频或视频，可设置为 &quot;auto&quot;、&quot;metadata&quot; 或 &quot;none&quot;--&gt;
&lt;audio controls autoplay loop preload=&quot;auto&quot;&gt;  
  &lt;source src=&quot;horse.ogg&quot; type=&quot;audio/ogg&quot;&gt;  
  &lt;source src=&quot;horse.mp3&quot; type=&quot;audio/mpeg&quot;&gt;  
  &lt;source src=&quot;horse.mp3&quot; type=&quot;audio/wav&quot;&gt; 
&lt;/audio&gt;
</code></pre>
<p><code>ps:音频和视频都有autoplay、loop、preload属性</code></p>
<p>音频文件类型各个浏览器支持情况</p>
<table>
<thead>
<tr>
<th>浏览器</th>
<th>MP3</th>
<th>Wav</th>
<th>Ogg</th>
</tr>
</thead>
<tbody><tr>
<td>Internet Explorer</td>
<td>YES</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr>
<td>Chrome</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>Firefox</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>Safari</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr>
<td>Opera</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
</tr>
</tbody></table>
<h3 id="Canvas绘图"><a href="#Canvas绘图" class="headerlink" title="Canvas绘图"></a>Canvas绘图</h3><p>一般用于组合图片，或者在图片上绘制文字，生成二维码，绘制动画效果等，下面是一个简单的例子</p>
<pre><code class="html">&lt;!--定义一个空白的画布--&gt;
&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot; style=&quot;border:1px solid red;&quot;&gt;
&lt;/canvas&gt;
&lt;script&gt;
// 获取Canvas元素的上下文
    const canvas = document.getElementById(&#39;myCanvas&#39;);//通过id获取canvas对象
    const ctx = canvas.getContext(&#39;2d&#39;);//获取2D上下文，用于进行绘图操作
    // 绘制矩形
    ctx.fillStyle = &#39;green&#39;;//设置填充颜色
    ctx.fillRect(10, 10, 150, 80);//fillRect(x, y, width, height)绘制填充的矩形
    // 绘制文本
    ctx.fillStyle = &#39;white&#39;;//设置填充颜色
    ctx.font = &#39;20px Arial&#39;;//设置字体样式
    ctx.fillText(&#39;我要吃烤鸭!&#39;, 20, 50);//fillText(text, x, y)在画布上绘制填充文本
    // 绘制路径（三角形）
    ctx.beginPath();//创建一条路径
    ctx.moveTo(10, 80);//moveTo(x, y)创建指定一个坐标
    ctx.lineTo(85, 10);//lineTo(x，y)绘制一条从当前点到指定坐标的直线
    ctx.lineTo(160, 80);
    ctx.closePath();//闭合路径，连接起点和终点
    ctx.stroke();//绘制路径的边框
&lt;/script&gt;
</code></pre>
<h3 id="SVG绘图"><a href="#SVG绘图" class="headerlink" title="SVG绘图"></a>SVG绘图</h3><pre><code class="html">&lt;svg&gt;
  &lt;ellipse cx=&quot;150&quot; cy=&quot;80&quot; rx=&quot;100&quot; ry=&quot;50&quot; style=&quot;fill:yellow;stroke:purple;stroke-width:2&quot; /&gt;
&lt;/svg&gt;
</code></pre>
<p>ps：svgs是W3C推荐标准，优点有如下几个（可能不全），都是我印象中的，更多的svg内容可以参考<a target="_blank" rel="noopener" href="https://www.w3cschool.cn/svg/svg-tutorial.html">svg教程</a>学习，我平时都是要求ui给出svg图片。 </p>
<blockquote>
<p>图像在放大或改变尺寸的情况下其图形质量不会有所损失</p>
<p>使用 XML 格式定义图形,内容更容易被搜索和识别。</p>
<p>相对png之类的可以更好的被压缩</p>
</blockquote>
<h3 id="地理定位Geolocation"><a href="#地理定位Geolocation" class="headerlink" title="地理定位Geolocation"></a>地理定位Geolocation</h3><pre><code class="html">//geolocation对象的3个方法
//window.navigator.geolocation &#123; 
//    getCurrentPosition: fn //用于获取当前的位置数据 
//    watchPosition: fn //监视用户位置的改变 
//    clearWatch: fn //清除定位监视
//&#125;　
&lt;p id=&quot;demo&quot;&gt;点击按钮获取您当前坐标（可能需要比较长的时间获取）：&lt;/p&gt;
&lt;button onclick=&quot;getLocation()&quot;&gt;点我&lt;/button&gt;
&lt;script&gt;
var x=document.getElementById(&quot;demo&quot;);
function getLocation()&#123;
  let success = (position)=&gt;&#123;
       console.log(&#39;定位时间：&#39;,position.timestamp)
　　　　console.log(&#39;经度：&#39;,position.coords.longitude)
　　　　console.log(&#39;纬度：&#39;,position.coords.latitude)
　　　　console.log(&#39;海拔：&#39;,position.coords.altitude)
　　　　console.log(&#39;速度：&#39;,position.coords.speed)	
  &#125;
  let error = (error)=&gt;&#123;
      switch(error.code) &#123;
        case error.PERMISSION_DENIED:
          x.innerHTML=&quot;用户拒绝对获取地理位置的请求。&quot;
          break;
        case error.POSITION_UNAVAILABLE:
          x.innerHTML=&quot;位置信息是不可用的。&quot;
          break;
        case error.TIMEOUT:
          x.innerHTML=&quot;请求用户地理位置超时。&quot;
          break;
        case error.UNKNOWN_ERROR:
          x.innerHTML=&quot;未知错误。&quot;
          break;
       &#125;
  &#125;
  navigator.geolocation ? navigator.geolocation.getCurrentPosition(success,error):(x.innerHTML=&quot;Geolocation is not supported by this browser.&quot;)
&#125;
&lt;/script&gt;
</code></pre>
<h3 id="拖拽API"><a href="#拖拽API" class="headerlink" title="拖拽API"></a>拖拽API</h3><pre><code class="html">&lt;p&gt;拖动红色div到矩形中:&lt;/p&gt;
&lt;!--ondrop监听拖动结束事件--&gt;
&lt;div id=&quot;div1&quot; style=&quot;width:350px;height:70px;padding:10px;border:1px solid #aaaaaa;&quot; ondrop=&quot;drop(event)&quot; ondragover=&quot;allowDrop(event)&quot;&gt;&lt;/div&gt;
&lt;br&gt;
&lt;!--draggable开启可被拖动,ondragstart监听拖拽开始事件--&gt;
&lt;div id=&quot;drag1&quot; style=&quot;background:red;&quot; draggable=&quot;true&quot; ondragstart=&quot;drag(event)&quot;&gt;
今天吃了大份的猪脚饭啊
&lt;/div&gt;

&lt;script&gt;
function allowDrop(ev)
&#123;
    ev.preventDefault();
&#125;

function drag(ev)
&#123;
    ev.dataTransfer.setData(&quot;Text&quot;,ev.target.id);
&#125;

function drop(ev)
&#123;
    ev.preventDefault();
    var data=ev.dataTransfer.getData(&quot;Text&quot;);
    ev.target.appendChild(document.getElementById(data));
&#125;
&lt;/script&gt;
</code></pre>
<p>拖拽API事件</p>
<table>
<thead>
<tr>
<th>拖动生命周期</th>
<th>属性名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>拖动开始</td>
<td>ondragstart</td>
<td>在拖动操作开始时执行脚本</td>
</tr>
<tr>
<td>拖动过程中</td>
<td>ondrag</td>
<td>只要脚本在被拖动就运行脚本</td>
</tr>
<tr>
<td>拖动过程中</td>
<td>ondragenter</td>
<td>当元素被拖动到一个合法的防止目标时，执行脚本</td>
</tr>
<tr>
<td>拖动过程中</td>
<td>ondragover</td>
<td>只要元素正在合法的防止目标上拖动时，就执行脚本</td>
</tr>
<tr>
<td>拖动过程中</td>
<td>ondragleave</td>
<td>当元素离开合法的防止目标时，就执行脚本</td>
</tr>
<tr>
<td>拖动结束</td>
<td>ondrop</td>
<td>将被拖动元素放在目标元素内时运行脚本</td>
</tr>
<tr>
<td>拖动结束</td>
<td>ondragend</td>
<td>在拖动操作结束时运行脚本</td>
</tr>
</tbody></table>
<h3 id="WebWorker"><a href="#WebWorker" class="headerlink" title="WebWorker"></a>WebWorker</h3><p>web worker 是运行在后台的非阻塞性质的 JavaScript，不会影响页面的性能，更好的解释是，你可以使用web worker提供的一种简单的方法来为web内容在后台线程中运行脚本，这些线程在执行任务的过程中并不会干扰用户界面，并且这个worker的数量是有上限的一般取决于cpu的内核数量如果是8核cpu，那最多就创建8个最佳，否则也是会影响性能的。<br>主要优势是</p>
<ul>
<li><p><strong>并行处理</strong>：可以同时执行多个任务，而不会相互阻塞，特别是在多核CPU上。</p>
</li>
<li><p><strong>性能提升</strong>：对于密集型任务，Web Workers可以提高应用程序的整体性能和响应速度。</p>
</li>
<li><p><strong>用户体验改善</strong>：主线程（通常是UI线程）不会因为需要执行复杂计算而被阻塞，因此应用程序仍然可以响应用户操作。</p>
</li>
</ul>
<pre><code class="ts">//work.js
var i=0; 
function timedCount()&#123;  
    i=i+1;  
    postMessage(i); //通过 postMessage发送结果到前端（比如下载进度百分比，上传进度百分比等）
    let time = setTimeout(()=&gt;&#123;
    time = null
    timedCount()
    &#125;,500);  
&#125;  
timedCount();
//使用的时候
let works_a=new Worker(&quot;demo_workers.js&quot;);
let works_b=new Worker(&quot;demo_workers.js&quot;);
works.onmessage = function (event) &#123; 
    //接收Worker的回传信息
    console.log(event.data)
&#125;
//停止works
works.terminate();
</code></pre>
<h3 id="WebStorage离线存储"><a href="#WebStorage离线存储" class="headerlink" title="WebStorage离线存储"></a>WebStorage离线存储</h3><p>离线存储允许web应用在用户的设备上本地保存数据，这样即使在没有网络连接的情况下，用户也能加载和使用应用。离线存储的目的是提高应用的性能和可用性，得到更好的用户体验。目前常用的有LocalStorage、SessionStorage和IndexedDB、Cookie</p>
<h4 id="LocalStorage、SessionStorage、IndexedDB、Cookie的区别"><a href="#LocalStorage、SessionStorage、IndexedDB、Cookie的区别" class="headerlink" title="LocalStorage、SessionStorage、IndexedDB、Cookie的区别"></a>LocalStorage、SessionStorage、IndexedDB、Cookie的区别</h4><ol>
<li><p><strong>LocalStorage</strong>:</p>
<ul>
<li>用于长期存储数据，数据没有过期时间，除非主动删除数据，否则数据永远不会消失。</li>
<li>存储容量较大，一般在5MB左右。</li>
<li>只能存储字符串，因此需要将对象JSON序列化。</li>
</ul>
</li>
<li><p><strong>SessionStorage</strong>:</p>
<ul>
<li>用于临时存储数据，数据仅在页面会话期间存在，页面关闭则数据消失。</li>
<li>和 LocalStorage 类似，但它的作用域限于单个页面会话。</li>
<li>存储容量和 LocalStorage 相似，也主要用于存储字符串数据。</li>
</ul>
</li>
<li><p><strong>IndexedDB</strong>:</p>
<ul>
<li>是一个低级API用于客户端存储大量结构化数据，包括文件&#x2F;二进制大对象。</li>
<li>支持事务，可以存储和操作大量数据。</li>
<li>存储容量比 LocalStorage 和 SessionStorage 大得多。</li>
<li>允许你创建索引来高效查询数据。</li>
</ul>
</li>
<li><p><strong>Cookie</strong>:</p>
<ul>
<li>按照域名存储，你在哪一个域名下存储的内容, 就在哪一个域名下使用， 其他域名都用不了， 和资源路径地址没有关系。</li>
<li>存储大小有限制，4KB 左右或者50 条左右。</li>
<li>时效性，默认是会话级别的时效性(关闭浏览器就没有了)，可以手动设置。</li>
<li>请求自动携带，当你的 cookie 空间里面有内容的时候，只要是当前域名下的任意一个请求, 都会自动携带 cookie 放在请求头里面， cookie 里面有多少自动携带多少，没有就不会携带了。</li>
<li>安全性不高，不建议存储敏感数据<br>示例</li>
</ul>
</li>
</ol>
<pre><code class="html">&lt;!-- 保存设置按钮 --&gt; 
&lt;button onclick=&quot;saveSettings()&quot;&gt;保存到LocalStorage&lt;/button&gt;
&lt;button onclick=&quot;saveSessionSettings()&quot;&gt;保存到SessionStorage&lt;/button&gt;
&lt;button onclick=&quot;saveIndexedDBSettings()&quot;&gt;保存到IndexedDB&lt;/button&gt;
&lt;!-- 读取设置按钮 --&gt; 
&lt;button onclick=&quot;loadSettings()&quot;&gt;从LocalStorage读取&lt;/button&gt;
&lt;button onclick=&quot;loadSessionSettings()&quot;&gt;从SessionStorage读取&lt;/button&gt;
&lt;button onclick=&quot;loadIndexedDBSettings()&quot;&gt;从IndexedDB读取&lt;/button&gt;
&lt;!-- 显示设置的区域 --&gt; 
&lt;div id=&quot;settings&quot;&gt;&lt;/div&gt; 
&lt;script&gt; 
// LocalStorage 示例 
function saveSettings() &#123; // 保存设置到LocalStorage  
    localStorage.setItem(&#39;favoriteChampion&#39;, &#39;炸鸡&#39;);
    localStorage.setItem(&#39;resolution&#39;, &#39;烤串&#39;);
    console.log(&#39;设置已保存到LocalStorage&#39;); 
&#125; 
function loadSettings() &#123;
    // 从LocalStorage读取设置 
    const favoriteChampion = localStorage.getItem(&#39;favoriteChampion&#39;);
    const resolution = localStorage.getItem(&#39;resolution&#39;); 
    document.getElementById(&#39;settings&#39;).innerText = `LocalStorage - 最喜欢的食物是: $&#123;favoriteChampion&#125;和 $&#123;resolution&#125;`;
    console.log(&#39;从LocalStorage读取设置&#39;);
&#125; 
// SessionStorage 示例 
function saveSessionSettings() &#123; // 保存设置到SessionStorage
    sessionStorage.setItem(&#39;sessionFavoriteChampion&#39;, &#39;薯条&#39;); 
    sessionStorage.setItem(&#39;sessionResolution&#39;, &#39;汉堡&#39;);
    console.log(&#39;会话设置已保存到SessionStorage&#39;); 
&#125; 
function loadSessionSettings() &#123; // 从SessionStorage读取设置 
    const sessionFavoriteChampion = sessionStorage.getItem(&#39;sessionFavoriteChampion&#39;); 
    const sessionResolution = sessionStorage.getItem(&#39;sessionResolution&#39;); 
    document.getElementById(&#39;settings&#39;).innerText = `SessionStorage - 最喜欢的食物是: $&#123;sessionFavoriteChampion&#125;和 $&#123;sessionResolution&#125;`; 
    console.log(&#39;从SessionStorage读取设置&#39;); 
&#125; 
// IndexedDB 示例 
var db; 
// 打开数据库 
var request = indexedDB.open(&#39;LoLSettingsDB&#39;, 1); 
request.onerror = function(event) &#123; // 处理打开数据库时的错误 
    console.log(&#39;打开IndexedDB时发生错误。&#39;);
&#125;; 
request.onupgradeneeded = function(event) &#123; // 数据库升级或首次创建时执行
    db = event.target.result; 
    if (!db.objectStoreNames.contains(&#39;settings&#39;)) &#123; 
        var objectStore = db.createObjectStore(&#39;settings&#39;, &#123; keyPath: &#39;id&#39; &#125;); 
        objectStore.createIndex(&#39;favoriteChampion&#39;, &#39;favoriteChampion&#39;, &#123; unique: false &#125;); 
        objectStore.createIndex(&#39;resolution&#39;, &#39;resolution&#39;, &#123; unique: false &#125;); 
    &#125;
&#125;; 
request.onsuccess = function(event) &#123; // 成功打开数据库 
    db = event.target.result; 
    console.log(&#39;IndexedDB成功打开&#39;); 
&#125;; 
function saveIndexedDBSettings() &#123; // 保存设置到IndexedDB 
    var transaction = db.transaction([&#39;settings&#39;], &#39;readwrite&#39;);
    var objectStore = transaction.objectStore(&#39;settings&#39;);
    var userSettings = &#123; id: &#39;food&#39;, favoriteChampion: &#39;鸡腿&#39;, resolution: &#39;鸭腿&#39; &#125;; 
    var request = objectStore.put(userSettings); 
    request.onsuccess = function(event) &#123; 
        console.log(&#39;食物设置已保存到IndexedDB&#39;);
    &#125;; 
    request.onerror = function(event) &#123; 
        console.log(&#39;保存设置到IndexedDB时发生错误&#39;); 
    &#125;; 
&#125;
function loadIndexedDBSettings() &#123; // 从IndexedDB读取设置 
    var transaction = db.transaction([&#39;settings&#39;]); 
    var objectStore = transaction.objectStore(&#39;settings&#39;); 
    var request = objectStore.get(&#39;food&#39;); 
    request.onsuccess = function(event) &#123; 
        if (request.result) &#123; 
            document.getElementById(&#39;settings&#39;).innerText = `IndexedDB - 最喜欢的食物是: $&#123;request.result.favoriteChampion&#125;和 $&#123;request.result.resolution&#125;`; 
            console.log(&#39;从IndexedDB读取食物设置&#39;); 
        &#125; else &#123; 
            console.log(&#39;在IndexedDB中未找到食物设置&#39;);
        &#125;
    &#125;; 
    request.onerror = function(event) &#123; 
        console.log(&#39;从IndexedDB读取时发生错误&#39;);
    &#125;; 
&#125;
&lt;/script&gt;
</code></pre>
<h3 id="WebSocket长连接"><a href="#WebSocket长连接" class="headerlink" title="WebSocket长连接"></a>WebSocket长连接</h3><p>WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p>
<pre><code class="ts">//web_socket_utils.js
 export const WebSocketTest =(call_back)=&gt;&#123;
    if (&quot;WebSocket&quot; in window)&#123;
       //浏览器支持 WebSocket 打开一个 web socket
       const ws = new WebSocket(&quot;ws://localhost:9998/echo&quot;);
       ws.onopen = function()
       &#123;
          // Web Socket 已连接上，使用 send() 方法发送数据
          ws.send(&quot;发送数据&quot;);
       &#125;;

       ws.onmessage = function (evt) 
       &#123; 
          call_back(evt.data)
       &#125;;
        ws.error = function (evt) 
       &#123; 
          call_back(evt.data)
       &#125;;
       ws.onclose = function()
       &#123; 
          // 关闭 websocket
       &#125;;
       ws.onopen()
    &#125;else&#123;
       // 浏览器不支持 WebSocket
    &#125;
 &#125;
 //使用WebSocketTest的时候
 import &#123;WebSocketTest&#125; from &#39;./web_socket_utils&#39;
 let get_server_data = (data)=&gt;&#123;
     //socket返回的数据data
 &#125;
  WebSocketTest(get_server_data)
</code></pre>
<h3 id="HTML5移除的标签"><a href="#HTML5移除的标签" class="headerlink" title="HTML5移除的标签"></a>HTML5移除的标签</h3><p>1.样式标签：不再推荐使用一些样式标签，如<code>&lt;big&gt;</code>、<code>&lt;basefont&gt;</code>、<code>&lt;big&gt;</code>、<code>&lt;center&gt;</code>、<code>&lt;font&gt;</code>、<code>&lt;s&gt;</code>、<code>&lt;tt&gt;</code>、<code>&lt;u&gt;</code>、<code>&lt;strike&gt;</code>等，应使用CSS来设置样式。</p>
<p>2.部分浏览器支持的元素:<code>&lt;applet&gt;</code>、<code>&lt;bgsound&gt;</code>、<code>&lt;blink&gt;</code>、<code>&lt;marquee&gt;</code>、<code>&lt;object&gt;</code>：HTML5不再推荐使用<code>&lt;applet&gt;</code>和<code>&lt;object&gt;</code>标签来嵌入Java小程序或其他外部插件，而是鼓励使用<code>&lt;embed&gt;</code>、<code>&lt;video&gt;</code>、<code>&lt;audio&gt;</code>等标签。</p>
<p>3.对可用性产生负面影响:<code>&lt;frameset&gt;</code>、<code>&lt;frame&gt;</code>、<code>&lt;noframes&gt;</code>：html5中不支持frame框架，只支持iframe框架，推荐使用<code>&lt;iframe&gt;</code>或其他技术来实现相同效果。</p>
<ol start="4">
<li>其他标签：</li>
</ol>
<ul>
<li>废除<code>&lt;menu&gt;</code>标签，推荐使用无序列表<code>&lt;ul&gt;</code>替代</li>
<li>废除<code>&lt;rb&gt;</code>，使用<code>&lt;ruby&gt;</code>替代</li>
<li>废除<code>&lt;acronym&gt;</code>使用<code>&lt;abbr&gt;</code>替代</li>
<li>废除<code>&lt;dir&gt;</code>使用<code>&lt;ul&gt;</code>替代</li>
<li>废除<code>&lt;isindex&gt;</code>使用<code>&lt;form&gt;</code>与<code>&lt;input&gt;</code>相结合的方式替代</li>
<li>废除<code>&lt;listing&gt;</code>使用<code>&lt;pre&gt;</code>替代</li>
<li>废除<code>&lt;xmp&gt;</code>使用<code>&lt;code&gt;</code>替代</li>
<li>废除<code>&lt;nextid&gt;</code>使用<code>&lt;guids&gt;</code>替代</li>
<li>废除<code>&lt;plaintex&gt;</code>使用“text&#x2F;plian”（无格式正文）MIME类型替代</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>梳理了HTML5的知识点，如果有不对的地方也希望大家指正。</p>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 木子的博客
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;lish
        </div>
        <!-- <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div> -->
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
</body>
</html>
